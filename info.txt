1) Playwright Test is based on the concept of test fixtures. 
Test fixtures are used to establish environment for each test, giving the test everything 
it needs and nothing else. 
Test fixtures are isolated between tests.

2) Before and After hooks:
Execute an action before and after each step or test. There are times when it's necessary to 
run a specific action before or after each step or test

3) Test Fixtures
Test fixture refers to the fixed state used as a baseline for running tests in software testing. 
The purpose of a test fixture is to ensure that there is a well known and fixed environment in which tests are run so that results are repeatable. Some people call this the test context.

Examples of fixtures:

Loading a database with a specific, known set of data
Erasing a hard disk and installing a known clean operating system installation
Copying a specific known set of files
Preparation of input data and set-up/creation of fake or mock objects...

4) Test hooks
General definition: A hook is a means of executing custom code (function) either before, after, or instead of existing code. 
For example, a function may be written to "hook" into the login process in order to execute a Captcha function 
before continuing on to the normal login process.
In relation to playwright, you can use various test hooks such as test.describe to declare a group of tests and test.beforeEach 
and test.afterEach which are executed before/after each test. Other hooks include the test.beforeAll 
and test.afterAll which are executed once per worker before/after all tests.

test.afterAll(async () => {
  console.log('Done with tests');
  // ...
});
Declares an afterAll hook that is executed once per worker after all tests.

5) Require(argument). this function is similar to import function.
In NodeJS, require() is a built-in function to include external modules that exist in separate files. require() statement basically reads a JavaScript file, executes it, and then proceeds to return the export object. 
require() statement not only allows to add built-in core NodeJS modules but also community-based and local modules.
One of the major differences between require() and import() is that require() can be called from anywhere inside the program whereas import() cannot be called conditionally, it always runs at the beginning of the file.

To use the require() statement, a module must be saved with .js extension as opposed to .mjs when the import() statement is used.

6) HOISTING: Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution. 
var: variables are hoisted to the top of their scope and initialized with a value of undefined.
let: declarations are hoisted to the top. Unlike var which is initialized as undefined, the let keyword is not initialized. 
  if you try to use a let variable before declaration, you'll get a Reference Error.
Const: declarations are hoisted to the top but are not initialized.

7) Var vs Const vs Let
VAR: The scope is global when a var variable is declared outside a function. var is function scoped when it is declared within a function.
	var variables can be re-declared and updated.
LET: let is now preferred for variable declaration.let is block scoped. A block is a chunk of code bounded by {}. A block lives in curly braces. 
Anything within curly braces is a block. So a variable declared in a block with let  is only available for use within that block.
let can be updated but not re-declared.


CONST: Variables declared with the const maintain constant values. const declarations share some similarities with let declarations.
const declarations are block scoped. **const cannot be updated or re-declared**
Every const declaration, therefore, must be initialized at the time of declaration.
This behavior is somehow different when it comes to objects declared with const. While a const object cannot be updated, the properties of this objects can be updated.
const declarations are hoisted to the top but are not initialized.


8) Functions: functions are first-class citizens in JavaScript. Therefore, you can pass a function to another function as an argument.

Anonymous functions: function without a name.An anonymous function is not accessible after its initial creation. Therefore, you often need to assign it to a variable.
Note that if you don’t place the anonymous function inside the (), you’ll get a syntax error. 
The () makes the anonymous function an expression that returns a function object.
Anonymous functions can be used as an argument to other functions or as an immediately invoked function execution.

Immediately invoked function execution.
(function () {
    console.log('Immediately invoked function execution');
})();

Arrow function: shorthand for declaring anonymous function.

9) **When you define a function, the JavaScript engine adds the function to the global object.
**Likewise, if you declare a variable outside of a function using the var keyword, the JavaScript engine also adds the variable to the global object.
If you have many global variables and functions, the JavaScript engine will only release the memory allocated for them until the global object loses its scopes.
As a result, the script may use the memory inefficiently. On top of that, having global variables and functions will likely cause name collisions.
One way to prevent the functions and variables from polluting the global object is to use immediately invoked function expressions.
By placing functions and variables inside an immediately invoked function expression, you can avoid polluting them to the global object.

(function() {
    var counter = 0;

    function add(a, b) {
        return a + b;
    }

    console.log(add(10,20)); // 30
}());
An IIFE can have a name. However, it cannot be invoked again after execution:

10)  function can be also declared as an expression which is called a function expression:
let sum = (function(a, b) {
    return a + b;
})
In this syntax, the part on the right side of the assignment operator(=) is a function expression. Because a function is an expression, you can wrap it inside parentheses.

11) Function methods: apply, call, and bind
A function object has three important methods: apply(), call() and bind(). 
bind(), call(), and apply() methods are also known as borrowing functions (explained at the end).

The apply() and call() methods call a function with a given 'this' value and arguments.

The difference between the apply() and call() is that you need to pass the arguments to the apply() 
method as an array-like object, whereas you pass the arguments to the call() function individually.

The bind() method creates a new function instance whose this value is bound to the object that you provide.
bind() method creates a new function that you can execute later while the call() method executes the function immediately.

12) JavaScript functions can return a single value. To return multiple values from a function, you can pack the return values as 
elements of an array or as properties of an object.

13) DESTRUCTURING
Note: Curly brackets ‘{ }’ are used to destructure the JavaScript Object properties.
Note: Curly brackets ‘[ ]’ are used to destructure the JavaScript Array.

14) Primitive vs Reference value:
Primitive values are atomic pieces of data while reference values are objects that might consist of multiple values.
Note that 'strings' are objects in many programming languages, including Java and C#. However, strings are primitive values in JavaScript.
Reference variable is a variable stored in STACK memory that refers to an object on HEAP memory.
Because static data has a size that does not change, the JavaScript engine allocates a fixed amount of memory space to the static data and store it on the stack.
Static data is the data whose size is fixed at compile time. Static data includes:
a) Primitive values (null, undefined, boolean, number, string, symbol, and BigInt)
b) Reference values that refer to objects.

Non-Static data is stored in HEAP memory. JavaScript 'object's and 'functions' are non-static and live in heap.
The JavaScript engine doesn’t allocate a fixed amount of memory for these objects. Instead, it’ll allocate more space as needed.
Unlike a reference value, a primitive value cannot have properties. This means that you cannot add a property to a primitive value.
JavaScript allows you to add a property to a primitive value. However, it won’t take any effect.

COpying a value:
When you assign a primitive value from one variable to another, the JavaScript engine creates a SEPARATE copy of that value and assigns it to the variable.
If you change the value of one variable, it won’t affect the other. 

When you assign a reference value from one variable to another, the JavaScript engine creates a reference so that both variables refer to the same object on the heap memory. 
This means that if you change one variable, it’ll affect the other.

15) JavaScript pass-by-value or pass-by-reference:
JavaScript passes all arguments to a function by values.
Function arguments are local variables in JavaScript.
In JavaScript, all function arguments are always passed by value. It means that JavaScript copies the values of the variables into the function arguments.
Any changes that you make to the arguments inside the function do not reflect the passing variables outside of the function. 
In other words, the changes made to the arguments are not reflected outside of the function.

If function arguments are passed by reference, the changes of variables that you pass into the function will be reflected outside the function. 
This is not possible in JavaScript.

16) Function are firstclass citizens: An entity that can be constructed at run-time, passed as a parameter, returned from a function, or assigned into a variable.
You can pass functions to other functions as arguments, return them from other functions as values, and store them in variables.
"If any programming language has the ability to treat functions as values, to pass them as arguments and to return a function from another function then it is 
said that programming language has First Class Functions and the functions are called as First Class Citizens in that programming language."
 In languages with first-class functions, the names of functions do not have any special status; they are treated like ordinary variables with a function type.
 A member of a class of individuals that receive fair treatment.
 **Very loosely, this just means we can use a function in the same way we use a variable.

 17) Every object in JavaScript has a built-in property, which is called its prototype. The prototype is itself an object, so the 
 prototype will have its own prototype, making what's called a prototype chain. 
 The chain ends when we reach a prototype that has null for its own prototype.

18) **Callback: a callback is a function that you pass into another function as an argument to execute at a later time.

18) **The setTimeout() is a method of the window object. The setTimeout()  sets a timer and executes a callback function after the timer expires.

19) **PROMISE: a promise is an object that encapsulates the result of an asynchronous operation.
A promise object has a state that can be one of the following:
Pending
Fulfilled with a value
Rejected for a reason
In the beginning, the state of a promise is pending, indicating that the asynchronous operation is in progress. 
Depending on the result of the asynchronous operation, the state changes to either fulfilled or rejected.

20) **For Loop: For..of vs For..in
Difference for..in and for..of:
Both for..in and for..of are looping constructs which are used to iterate over data structures. The only difference between them is the entities they iterate over:

for..in iterates over all enumerable property keys of an object
for..of iterates over the values of an iterable object. Examples of iterable objects are arrays, strings, and NodeLists.
The values which an iterable data structure will return using for..of is dependent on the type of iterable object. 
For example an array will return the values of all the array elements whereas a string returns every individual character of the string

21) String literals vs OBject literals:
A string literal is zero or more characters enclosed in double (") or single quotation marks (')
eg: "foo"
An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}).
eg: const car = {
  myCar: "Toyota",
};

22) Constructor:
A constructor is just a function called using the new keyword. When you call a constructor, it will:
-create a new object
-bind 'this' to the new object, so you can refer to this in your constructor code
-run the code in the constructor
-return the new object.
Constructors, by convention, start with a capital letter and are named for the type of object they create.

23) Object Prototype:
Prototypes are the mechanism by which JavaScript objects inherit features from one another.
Every object in JavaScript has a built-in property, which is called its prototype. The prototype is itself an object, so the prototype 
will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.
